{
    "contents" : "# This file includes following functions\n# duane, littlewood.verall, moranda.geometric, musa.okumoto, musa.basic, jelinski.moranda\n\n\n# Function for estimating the parameters of the Duane model \n\"duane\" <- function(t, init = c(1, 1), method = \"Nelder-Mead\", maxit = 10000, ...) \n{\n  eq1 <- function(rho, theta, t) \n  {\n    n <- length(t)\n    t <- cumsum(t)\n    i <- seq(along = t)\n    tn <- t[length(t)]\n    rho - n / (tn^theta)\n  }\n  \n  eq2 <- function(rho, theta, t) \n  {\n    i <- seq(along = t[1:length(t) - 1])\n    n <- length(t)\n    t <- cumsum(t)\n    tn <- t[length(t)]\n    theta - n / (sum(log(tn / t[i])))  \n  }\n  \n  # Merging the two parts\n  global <- function(vec, t) \n  {\n    rho <- vec[1]\n    theta <- vec[2]\n    v1 <- eq1(rho, theta, t)^2\n    v2 <- eq2(rho, theta, t)^2\n    v1 + v2\n  }\n  \n  # Minimum search for rho and theta\n  res <- optim(init, global, t = t, method = method, \n               control = list(maxit = maxit, ...))\n  rho <- res$par[1]\n  theta <- res$par[2]\n  \n  return(list(rho = rho, theta = theta))\n}\n\n\n# Function for plotting the mean value function of the Duane model\n\n\"duane.plot\" <- function(rho, theta, t, xlab = \"time\", \n                         ylab = \"Cumulated failures and estimated mean value function\", \n                         main = NULL) \n{\n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,      \n       ylab = ylab)                                         \n  lines(cumsum(t), mvf.duane(rho, theta, cumsum(t)), lty = 2, type = \"o\", \n        pch = 4, cex = 0.8, col = \"mediumblue\")   \n  legend(\"bottomright\", c(\"Data\", \"Duane\"), col = c(\"black\", \"mediumblue\"), pch = c(3, 4), \n         lty = c(1, 2))    \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }                                                                                 \n}\n\n\n# Function for estimating the parameters of the Littlewood-Verall model \n\n\"littlewood.verall\" <- function(t, linear = T, init = c(1, 1, 1), method = \"Nelder-Mead\", \n                                maxit = 10000, ...) \n{\n  if(linear == T) \n  {\n    eq1 <- function(theta0, theta1, rho, t) \n    {\n      n <- length(t)\n      i <- seq(along = t)\n      s1 <- sum(log(theta0 + theta1 * i))\n      s2 <- sum(log(theta0 + theta1 * i + t[i]))\n      (n / rho) + s1 - s2\n    }\n    \n    eq2 <- function(theta0, theta1, rho, t) \n    {\n      i <- seq(along = t)\n      s1 <- rho * sum(1 / (theta0 + theta1 * i))\n      s2 <- (rho + 1) * sum(1 / (theta0 + theta1 * i + t[i]))\n      s1 - s2\n    }\n    \n    eq3 <- function(theta0, theta1, rho, t) \n    {\n      i <- seq(along = t)\n      s1 <- rho * sum(i / (theta0 + theta1 * i))\n      s2 <- (rho + 1) * sum(i / (theta0 + theta1 * i + t[i]))\n      s1 - s2\n    }\n    \n    # Merging the three parts\n    global.linear <- function(vec, t) \n    {\n      theta0 <- vec[1]\n      theta1 <- vec[2]\n      rho <- vec[3]\n      v1 <- eq1(theta0, theta1, rho, t)^2\n      v2 <- eq2(theta0, theta1, rho, t)^2\n      v3 <- eq3(theta0, theta1, rho, t)^2\n      v1 + v2 + v3\n    }\n    \n    # Minimum search for theta0, theta1 and rho\n    res <- optim(init, global.linear, t = t, method = method, \n                 control = list(maxit = maxit, ...))\n    theta0 <- res$par[1]\n    theta1 <- res$par[2]\n    rho <- res$par[3]\n    \n    # Repeated minimum search for theta0, theta1 and rho\n    res <- optim(c(theta0, theta1, rho), global.linear, t = t, method = method,\n                 control = list(maxit = maxit, ...))\n  }\n  else \n  {\n    eq1 <- function(theta0, theta1, rho, t) \n    {\n      n <- length(t)\n      i <- seq(along = t)\n      print(theta0 + theta1 * i^2)\n      s1 <- sum(log(theta0 + theta1 * i^2))\n      s2 <- sum(log(theta0 + theta1 * i^2 + t[i]))\n      (n / rho) + s1 - s2\n    }\n    \n    eq2 <- function(theta0, theta1, rho, t) \n    {\n      i <- seq(along = t)\n      s1 <- rho * sum(1 / (theta0 + theta1 * i^2))\n      s2 <- (rho + 1) * sum(1 / (theta0 + theta1 * i^2 + t[i]))\n      s1 - s2\n    }\n    \n    eq3 <- function(theta0, theta1, rho, t) \n    {\n      i <- seq(along = t)\n      s1 <- rho * sum((i^2) / (theta0 + theta1 * i^2))\n      s2 <- (rho + 1) * sum((i^2) / (theta0 + theta1 * i^2 + t[i]))\n      s1 - s2\n    }\n    \n    # Merging the three parts\n    global.quadratic <- function(vec, t) \n    {\n      theta0 <- vec[1]\n      theta1 <- vec[2]\n      rho <- vec[3]\n      v1 <- eq1(theta0, theta1, rho, t)^2\n      v2 <- eq2(theta0, theta1, rho, t)^2\n      v3 <- eq3(theta0, theta1, rho, t)^2\n      v1 + v2 + v3\n    }\n    \n    # Minimum search for theta0, theta1 and rho\n    res <- optim(init, global.quadratic, t = t, method = method, \n                 control = list(maxit = maxit, ...))\n    theta0 <- res$par[1]\n    theta1 <- res$par[2]\n    rho <- res$par[3]\n    \n    # Repeated minimum search for theta0, theta1 and rho\n    res <- optim(c(theta0, theta1, rho), global.quadratic, t = t, method = method,\n                 control = list(maxit = maxit, ...))\n  }\n  \n  theta0 <- res$par[1]\n  theta1 <- res$par[2]\n  rho <- res$par[3]\n  \n  return(list(theta0 = theta0, theta1 = theta1, rho = rho))\n}\n\n\n# Function for plotting the mean value function of the Littlewood-Verall model\n\n\"littlewood.verall.plot\" <- function(theta0, theta1, rho, t, linear = T, xlab = \"time\", \n                                     ylab = \"Cumulated failures and estimated mean value function\", main = NULL) \n{\n  if(linear == T) \n  {\n    mvf.ver <- mvf.ver.lin(theta0, theta1, rho, cumsum(t))\n    \n    plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab=xlab,\n         ylab = ylab)\n  }\n  else \n  {\n    mvf.ver <- mvf.ver.quad(theta0, theta1, rho, cumsum(t))\n    \n    plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,\n         ylab = ylab)\n  }\n  \n  lines(cumsum(t), mvf.ver, lty=2, type = \"o\", pch = 4, cex = 0.8, col=\"mediumblue\")\n  legend(\"bottomright\", c(\"Data\", \"Littlewood-Verall\"), col=c(\"black\", \"mediumblue\"), \n         pch=c(3, 4), lty=c(1, 2))  \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n\n# Function for estimating the parameters of the Moranda-Geometric model \n\n\"moranda.geometric\" <- function(t, init = c(0, 1), tol = .Machine$double.eps^0.25) \n{\n  # Function for computation of Dhat\n  Dhat <- function(phi, t) \n  {\n    n <- length(t)\n    i <- seq(along = t)\n    return(phi * n / (sum(phi^i * t[i])))\n  }\n  \n  # Squared Maximum Likelihood estimate for phihat\n  phihat <- function(phi, t) \n  {\n    i <- seq(along = t)\n    n <- length(t)\n    return((sum(i * (phi^i) * t[i]) / sum((phi^i) * t[i]) - (n + 1) / 2)^2)\n  }\n  \n  # Minimum search for phihat\n  min <- optimize(phihat, init, tol = tol, t = t)  \n  phi <- min$minimum\n  D <- Dhat(phi, t)\n  theta<- -log(phi)\n  \n  return(list(D = D, theta = theta))\n}\n\n\n# Function for plotting the mean value function of the Moranda-Geometric model\n\n\"moranda.geometric.plot\" <- function(D, theta, t, xlab = \"time\", \n                                     ylab = \"Cumulated failures and estimated mean value function\", main = NULL) \n{\n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,      \n       ylab = ylab)                                         \n  lines(cumsum(t), mvf.mor(D, theta, cumsum(t)), lty = 2, type = \"o\", pch = 4, \n        cex = 0.8, col = \"mediumblue\")  \n  legend(\"bottomright\", c(\"Data\", \"Moranda-Geometric\"), col=c(\"black\", \"mediumblue\"), \n         pch=c(3, 4), lty=c(1, 2)) \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n\n# Function for estimating the parameters of the Musa-Okumoto model \n\n\"musa.okumoto\" <- function(t, init = c(0, 1), tol = .Machine$double.eps^0.25) \n{\n  # Function for computation of theta0hat\n  theta0hat <- function(theta1, t) \n  {\n    n <- length(t)\n    t <- cumsum(t)\n    tn <- t[length(t)]\n    return(n / log(1 + theta1 * tn))\n  }\n  \n  # Squared Maximum Likelihood estimate for theta1hat\n  theta1hat <- function(theta1, t) \n  {\n    i <- seq(along = t)\n    n <- length(t)\n    t <- cumsum(t)\n    tn <- t[length(t)]\n    return((1 / theta1 * sum(1 / (1 + theta1 * t[i])) - n * tn / \n              ((1 + theta1 * tn) * log(1 + theta1 * tn)))^2)\n  }\n  \n  # Minimum search for theta1hat\n  min <- optimize(theta1hat, init, tol = tol, t = t)\n  theta1 <- min$minimum\n  theta0 <- theta0hat(theta1, t)\n  \n  return(list(theta0 = theta0, theta1 = theta1))\n}\n\n\n# Function for plotting the mean value function of the Musa-Okumoto model\n\n\"musa.okumoto.plot\" <- function(theta0, theta1, t, xlab = \"time\", \n                                ylab = \"Cumulated failures and estimated mean value function\", main = NULL) \n{\n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,\n       ylab = ylab)\n  lines(cumsum(t), mvf.musa(theta0, theta1, cumsum(t)), lty = 2, type = \"o\", \n        pch = 4, cex = 0.8, col = \"mediumblue\")\n  legend(\"bottomright\", c(\"Data\", \"Musa-Okumoto\"), col = c(\"black\", \"mediumblue\"), \n         pch = c(3, 4), lty = c(1, 2)) \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n\n# Function for plotting all mean value functions of all models in one plot.\n\n\"total.plot\" <- function(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4, \n                         musa.basic.par1, musa.basic.par2, duane.par1, duane.par2, lit.par1, lit.par2, lit.par3, \n                         mor.par1, mor.par2, musa.par1, musa.par2, t, linear = T, xlab = \"Time\",\n                         ylab = \"Cumulated failures and estimated mean value functions\", main = NULL)\n{\n  if(linear == T) \n  {\n    mvf.ver <- mvf.ver.lin(lit.par1, lit.par2, lit.par3, cumsum(t))\n  }\n  else \n  {\n    mvf.ver <- mvf.ver.quad(lit.par1, lit.par2, lit.par3, cumsum(t))\n  }\n  \n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,      \n       ylab = ylab)\n  lines(cumsum(t), mvf.duane(duane.par1, duane.par2, cumsum(t)), lty = 2,          \n        type = \"o\", pch = 4, cex = 0.8, col = \"mediumblue\")     \n  lines(cumsum(t), mvf.ver, lty = 3, type = \"o\", pch = 8, cex = 0.8, \n        col = \"steelblue\")    \n  lines(cumsum(t), mvf.mor(mor.par1, mor.par2, cumsum(t)), lty = 4,          \n        type = \"o\", pch = 0, cex = 0.8, col = \"skyblue\")   \n  lines(cumsum(t), mvf.musa(musa.par1, musa.par2, cumsum(t)), lty = 5,          \n        type = \"o\", pch = 15, cex = 0.8, col = \"royalblue\")   \n  lines(cumsum(t), mvf.musa.basic(musa.basic.par1,musa.basic.par2, cumsum(t)), lty = 6,\n        type = \"o\", pch = 16, cex = 0.8, col = \"lightseagreen\")   \n  lines(cumsum(t), mvf.jelinski.moranda(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3,\n                                        jelinski.moranda.par4, cumsum(t)), lty = 7,\n        type = \"o\", pch = 17, cex = 0.8, col = \"cornflowerblue\")   \n  legend(\"bottomright\", c(\"Data\", \"D\", \"LV\", \"MG\", \"MO\", \"BM\", \"JM\"), \n         col = c(\"black\", \"mediumblue\", \"steelblue\", \"skyblue\", \"royalblue\", \"lightseagreen\", \"cornflowerblue\" ),\n         pch = c(3, 4, 8, 0, 15, 16, 17),lty = c(1, 2, 3, 4, 5, 6, 7), horiz=T)\n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n\n\n# Function for calculating ranking based on mean absolute relative errors.\n\"rank.rel\" <- function(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4,\n                       musa.basic.par1, musa.basic.par2, duane.par1, duane.par2, lit.par1, lit.par2, lit.par3, mor.par1,\n                       mor.par2, musa.par1, musa.par2, t, linear = T)\n{\n  l <- 1:length(t)\n  Rrel.duane <- mean(abs((mvf.duane(duane.par1, duane.par2, cumsum(t)) - l) / l))\n  \n  if(linear == T) \n  {\n    Rrel.ver <- mean(abs((mvf.ver.lin(lit.par1, lit.par2, lit.par3, cumsum(t)) - l) / l))\n  }\n  else \n  {\n    Rrel.ver <- mean(abs((mvf.ver.quad(lit.par1, lit.par2, lit.par3, cumsum(t)) - l) / l))\n  } \n  \n  Rrel.mor <- mean(abs((mvf.mor(mor.par1, mor.par2, cumsum(t)) - l) / l))\n  Rrel.musa <- mean(abs((mvf.musa(musa.par1, musa.par2, cumsum(t)) - l) / l))\n  Rrel.musa.basic <- mean(abs((mvf.musa.basic(musa.basic.par1, musa.basic.par2, cumsum(t)) - l) / l))\n  Rrel.jelinski.moranda <- mean(abs((mvf.jelinski.moranda(jelinski.moranda.par1, jelinski.moranda.par2,\n                                                          jelinski.moranda.par3, jelinski.moranda.par4, cumsum(t)) - l) / l))\n  \n  mae <-c(Rrel.duane, Rrel.ver, Rrel.mor, Rrel.musa, Rrel.musa.basic, Rrel.jelinski.moranda) \n  meths <- c(\"Duane\", \"Littlewood-Verall\", \"Moranda Geometric\", \"Musa-Okumoto\", \"Musa Basic\",\"Jelinski-Moranda\")\n  m2 <- cbind(meths, mae)\n  colnames(m2, do.NULL = FALSE)\n  colnames(m2) <- c(\"Method\",\"Mean Absolute Relative Error\")\n  return(m2)\t\n}\n\n# Function for plotting all relative errors in one plot.\n\"rel.plot\" <- function(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4,\n                       musa.basic.par1, musa.basic.par2, duane.par1, duane.par2, lit.par1, lit.par2, lit.par3, mor.par1,\n                       mor.par2, musa.par1, musa.par2, t, linear = T, ymin, ymax, xlab = \"Time\", ylab = \"Relative error\", main = NULL)\n{\n  l <- 1:length(t)\n  rel.duane <- (mvf.duane(duane.par1, duane.par2, cumsum(t)) - l) / l\n  \n  if(linear == T) \n  {\n    rel.ver <- (mvf.ver.lin(lit.par1, lit.par2, lit.par3, cumsum(t)) - l) / l\n  }\n  else \n  {\n    rel.ver <- (mvf.ver.quad(lit.par1, lit.par2, lit.par3, cumsum(t)) - l) / l\n  } \n  \n  rel.mor <- (mvf.mor(mor.par1, mor.par2, cumsum(t)) - l) / l\n  rel.musa <- (mvf.musa(musa.par1, musa.par2, cumsum(t)) - l) / l\n  rel.musa.basic <- (mvf.musa.basic(musa.basic.par1, musa.basic.par2, cumsum(t)) - l) / l\n  rel.jelinski.moranda <- (mvf.jelinski.moranda(jelinski.moranda.par1, jelinski.moranda.par2,\n                                                jelinski.moranda.par3, jelinski.moranda.par4, cumsum(t)) - l) / l\n  \n  if(missing(ymin))\n  {\n    ymin <- min(c(rel.duane, rel.ver, rel.mor, rel.musa, rel.musa.basic))\n  }\n  \n  if(missing(ymax))\n  {\n    ymax <- max(c(rel.duane, rel.ver, rel.mor, rel.musa, rel.musa.basic))\n  }\n  \n  plot(cumsum(t), rel.duane, type = \"o\", pch = 4, cex = 0.8, col = \"mediumblue\",xlab = xlab, ylim = c(ymin, ymax), lty = 2, ylab = ylab)\n  lines(cumsum(t), rel.ver, lty = 3, type = \"o\", pch = 8, cex = 0.8, col = \"steelblue\")     \n  lines(cumsum(t), rel.mor, lty = 4, type = \"o\", pch = 0, cex = 0.8, col = \"skyblue\")    \n  lines(cumsum(t), rel.musa, lty = 5, type = \"o\", pch = 15, cex = 0.8, col = \"royalblue\")   \n  lines(cumsum(t), rel.musa.basic, lty = 6, type = \"o\", pch = 16, cex = 0.8, col = \"lightseagreen\")\n  lines(cumsum(t), rel.jelinski.moranda, lty = 7, type = \"o\", pch = 17, cex = 0.8, col = \"cornflowerblue\")\n  segments(-max(cumsum(t)) * 1.05, 0, max(cumsum(t)) * 1.05, 0, lty = 3)\n  legend(\"topright\", c(\"D\", \"LV\", \"MG\", \"MO\", \"BM\", \"JM\"), \n         col = c(\"mediumblue\", \"steelblue\", \"skyblue\", \"royalblue\", \"lightseagreen\", \"cornflowerblue\"), pch = c(4, 8, 0, 15, 16, 17), \n         lty = c(2, 3, 4, 5, 6, 7), horiz=T)\n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n\n# Function for plotting the predictions of all models in one plot.\n\n\"prediction.plot\" <- function(musaP, duaneP, lvP, okumotoP, geoP, jmP,\n                              jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4, \n                         musa.basic.par1, musa.basic.par2, duane.par1, duane.par2, lit.par1, lit.par2, lit.par3, \n                         mor.par1, mor.par2, musa.par1, musa.par2, t, linear = T, xlab = \"Time\",\n                         ylab = \"Cumulated failures and estimated mean value functions\", main = NULL)\n{\n   if(linear == T) \n   {\n      mvf.ver <- mvf.ver.lin(lit.par1, lit.par2, lit.par3, cumsum(t))\n   }\n   else \n   {\n      mvf.ver <- mvf.ver.quad(lit.par1, lit.par2, lit.par3, cumsum(t))\n   }\n   \n   if (lvP==F) mvf.ver <- 0\n   \n   if (duaneP==T) mvf.duane <- mvf.duane(duane.par1, duane.par2, cumsum(t))\n   else mvf.duane <- 0\n   \n   if (geoP == T )    mvf.mor <- mvf.mor(mor.par1, mor.par2, cumsum(t))\n   else mvf.mor <- 0\n   \n   if (okumotoP == T) mvf.musa <- mvf.musa(musa.par1, musa.par2, cumsum(t))\n   else mvf.musa <- 0\n   \n   if (musaP == T) mvf.musa.basic <- mvf.musa.basic(musa.basic.par1, musa.basic.par2, cumsum(t))\n   else  mvf.musa.basic <- 0\n   \n   if (jmP == T) mvf.jelinski.moranda <- mvf.jelinski.moranda(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4, cumsum(t))\n   else  mvf.jelinski.moranda <- 0\n   \n   \n   ymin <- min(c(mvf.duane, mvf.ver, mvf.mor, mvf.musa, mvf.musa.basic))\n   ymax <- max(c(mvf.duane, mvf.ver, mvf.mor, mvf.musa, mvf.musa.basic))\n   \n   plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, col=\"white\", xlab = xlab, ylab = ylab, ylim = c(ymin, ymax))\n   \n   if (duaneP == T) lines(cumsum(t), mvf.duane(duane.par1, duane.par2, cumsum(t)), lty = 2, type = \"o\", pch = 4, cex = 0.8, col = \"mediumblue\")     \n   \n   if (lvP == T) lines(cumsum(t), mvf.ver, lty = 3, type = \"o\", pch = 8, cex = 0.8, col = \"steelblue\")\n   \n   if (geoP == T) lines(cumsum(t), mvf.mor(mor.par1, mor.par2, cumsum(t)), lty = 4, type = \"o\", pch = 0, cex = 0.8, col = \"skyblue\")   \n   \n   if (okumotoP == T) lines(cumsum(t), mvf.musa(musa.par1, musa.par2, cumsum(t)), lty = 5, type = \"o\", pch = 15, cex = 0.8, col = \"royalblue\")\n   \n   if (musaP == T) lines(cumsum(t), mvf.musa.basic(musa.basic.par1,musa.basic.par2, cumsum(t)), lty = 6,type = \"o\", pch = 16, cex = 0.8, col = \"lightseagreen\")   \n   \n   if (jmP == T) lines(cumsum(t), mvf.jelinski.moranda(jelinski.moranda.par1, jelinski.moranda.par2, jelinski.moranda.par3, jelinski.moranda.par4, cumsum(t)), lty = 7, type = \"o\", pch = 17, cex = 0.8, col = \"cornflowerblue\")\n   \n   legend(\"top\", c(\"R\", \"D\", \"LV\", \"MG\", \"MO\", \"BM\", \"JM\"), \n          col = c(\"black\", \"mediumblue\", \"steelblue\", \"skyblue\", \"royalblue\", \"lightseagreen\", \"cornflowerblue\" ),\n          pch = c(3, 4, 8, 0, 15, 16, 17),lty = c(1, 2, 3, 4, 5, 6, 7),horiz = T)\n   \n   if(!is.null(main))\n   {\n      title(main)\n   }  \n}\n\n# Mean value function for Duane model\n\n\"mvf.duane\" <- function(rho, theta, t) \n{\n  if(rho <= 0 || theta <= 0)\n  {\n    stop(\"rho and theta should be larger than 0\")\n  }\n  \n  if(length(rho) != 1 || length(theta) != 1)\n  {\n    stop(\"rho and theta should have length 1\")\n  }\n  \n  return(rho * t^theta)\n}\n\n\n# Mean value function Moranda-Geometric model\n\n\"mvf.mor\" <- function(D, theta, t) \n{\n  if(theta <= 0)\n  {\n    stop(\"theta should be larger than 0\")\n  }\n  \n  if(length(D) != 1 || length(theta) != 1)\n  {\n    stop(\"D and theta should have length 1\")\n  }\n  \n  return(1 / theta * log((D * theta * exp(theta)) * t + 1))\n}\n\n\n# Mean Value Funktion Musa-Okumoto model\n\n\"mvf.musa\" <- function(theta0, theta1, t) \n{\n  if(length(theta0) != 1 || length(theta1) != 1)\n  {\n    stop(\"theta0 and theta1 should have length 1\")\n  }\n  \n  return(theta0 * log(theta1 * t + 1))\n}\n\n\n# Mean value function Littlewood-Verall model linear\n\n\"mvf.ver.lin\" <- function(theta0, theta1, rho, t) \n{\n  if(theta1 == 0)\n  {\n    stop(\"theta1 should not be equal 0\")\n  }\n  \n  if(length(theta0) != 1 || length(theta1) != 1 || length(rho) != 1)\n  {\n    stop(\"theta0, theta1 and rho should have length 1\")\n  }\n  \n  return(1 / theta1 * sqrt(theta0^2 + 2 * theta1 * t * rho))\n}\n\n\n# Mean value function Littlewood-Verall model quadratic \n\n\"mvf.ver.quad\" <- function(theta0, theta1, rho, t) \n{\n  if(theta1 == 0)\n  {\n    stop(\"theta1 should not be equal 0\")\n  }\n  \n  if(length(theta0) != 1 || length(theta1) != 1 || length(rho) != 1)\n  {\n    stop(\"theta0, theta1 and rho should have length 1\")\n  }\n  \n  v1 <- (rho - 1)^(1 / 3) / ((18 * theta1)^(1 / 3))\n  v2 <- 4 * (theta0^3) / (9 * (rho - 1)^2 * theta1)\n  Q1 <- (cumsum(t) + (cumsum(t)^2 + v2)^(1 / 2))^(1 / 3)\n  Q2 <- (cumsum(t) - (cumsum(t)^2 + v2)^(1 / 2))^(1 / 3)\n  \n  return(3 * v1 * (Q1 + Q2))\n}\n\n# Function for estimating the parameters of the Basic Musa model \n\n\"musa.basic\" <- function(t, x, init = c(0, 1), tol = .Machine$double.eps^0.25) \n{\n  # Function for computation of beta0hat\n  beta0hat <- function(beta1, t, x) \n  {\n    n <- length(t)\n    t <- cumsum(t)\n    tn <- t[length(t)]\n    return(n /( 1- exp(-beta1 * (tn + x))))\n  }\n  \n  # Squared Maximum Likelihood estimate for beta1hat\n  beta1hat <- function(beta1, t) \n  {\n    i <- seq(along = t)\n    n <- length(t)\n    t <- cumsum(t)\n    tn <- t[length(t)]\n    return((n / beta1 - n*(tn + x)/(exp(beta1 * (tn + x))-1) - sum(t[i]))^2)\n  }\n  \n  # Minimum search for theta1hat\n  min <- optimize(beta1hat, init, tol = tol, t = t)\n  beta1 <- min$minimum\n  beta0 <- beta0hat(beta1, t, x)\n  \n  return(list(beta0 = beta0, beta1 = beta1))\n}\n\n\n# Function for plotting the mean value function of the Musa-Okumoto model\n\n\"musa.basic.plot\" <- function(beta0, beta1, t, xlab = \"time\", \n                              ylab = \"Cumulated failures and estimated mean value function\", main = NULL) \n{\n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,\n       ylab = ylab)\n  lines(cumsum(t), mvf.musa.basic(beta0, beta1, cumsum(t)), lty = 2, type = \"o\", \n        pch = 4, cex = 0.8, col = \"mediumblue\")\n  legend(\"bottomright\", c(\"Data\", \"Basic Musa\"), col = c(\"black\", \"mediumblue\"), \n         pch = c(3, 4), lty = c(1, 2)) \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n# Mean Value Funktion Basic Musa model\n\n\"mvf.musa.basic\" <- function(beta0, beta1, t) \n{\n  if(length(beta0) != 1 || length(beta1) != 1)\n  {\n    stop(\"beta0 and beta1 should have length 1\")\n  }\n  \n  return(beta0 *(1 - exp(-beta1 * t)))\n}\n\n# Function for estimating the parameters of the Jelinski Moranda model \n\n\"jelisnki.moranda\" <- function(t, p, r, init = c(length(t), 150), tol = .Machine$double.eps^0.25) \n{\n  # Function for computation of phihat\n  phihat <- function(N0, t, p, r) \n  {\n    n <- length(t)\n    i <- seq(along = t)\n    s1 <- sum(t[i])\n    s2 <- sum((i-1)*(p-r)*t[i])\n    return( n/( N0*s1 - s2 ))\n  }\n  \n  # Maximum Likelihood estimate for N0hat\n  N0hat <- function(t, p, r) \n  {\n    n <- length(t)\n    s <- n\n    u <- n + 500 * n \n    i <- seq(along = t)\n    s1 <- sum(t[i])\n    s2 <- sum((i-1)*(p-r)*t[i])\n    rhsN <- n * s1\n    rho <- 1/(p-r)\n    \n    while ((u-s)>0.01){\n      N0 <- (s+u)/2;  \n      lhs <- sum( 1 / (N0 - (i - 1) / rho ))\n      rhsD <- sum( ( N0 - (i - 1) / rho ) * t[i] )\n      dif <- lhs - rhsN / rhsD;\n      if (dif < 0){\n        u <- N0\n      } else {\n        s <- N0\n      }\n    }\n    \n    return(ceiling(N0))\n  }\n  \n  # Search for N0hat\n  N0 <- N0hat(t, p, r)\n  phi <- phihat(N0, t, p, r)\n  \n  return(list(N0 = N0, phi = phi))\n}\n\n\n# Function for plotting the mean value function of the Jelinski-Moranda model\n\n\"jelinski.moranda.plot\" <- function(N0, phi, p, r, t, xlab = \"Time\", \n                                    ylab = \"Cumulated failures and estimated mean value function\", main = NULL) \n{\n  plot(cumsum(t), 1:length(t), type = \"o\", pch = 3, cex = 0.8, xlab = xlab,\n       ylab = ylab)\n  lines(cumsum(t), mvf.jelinski.moranda(N0, phi, p, r, cumsum(t)), lty = 2, type = \"o\", \n        pch = 4, cex = 0.8, col = \"mediumblue\")\n  legend(\"bottomright\", c(\"Data\", \"Jelinski-Moranda\"), col = c(\"black\", \"mediumblue\"), \n         pch = c(3, 4), lty = c(1, 2)) \n  \n  if(!is.null(main))\n  {\n    title(main)\n  }  \n}\n\n# Mean Value Funktion Jelinski-Moranda model\n\n\"mvf.jelinski.moranda\" <- function(N0, phi, p, r, t) \n{\n  if(length(N0) != 1 || length(phi) != 1 || length(p) != 1 || length(r) != 1)\n  {\n    stop(\"N0, phi, p and r should have length 1\")\n  }\n  \n  return(N0 *(1 - exp(-phi * ( p - r ) * t)))\n}",
    "created" : 1457644982698.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "397210820",
    "id" : "B7FDF0C9",
    "lastKnownWriteTime" : 1415576480,
    "path" : "C:/Users/aveleze/Desktop/Papadopulus Pispis/Proyecto-shiny-Eafit/Shiny-Eafit/Reliability.R",
    "project_path" : "Reliability.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}